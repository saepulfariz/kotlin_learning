/*
 * This source file was generated by the Gradle 'init' task
 */
package com.dicoding.kotlin

// Function Type
// Pada sub-modul selanjutnya, kita akan belajar tentang lambda dan higher-order function, namun sebelum itu kita perlu tahu terlebih dahulu apa itu function type. Seperti namanya, Anda dapat membuat sebuah fungsi menjadi tipe data. Menarik kan?

// Kotlin sendiri menggunakan function type untuk tipe deklarasi yang berhubungan dengan sebuah fungsi. Dalam penggunaannya, terdapat beberapa tanda yang berhubungan dengan sebuah fungsi seperti jumlah dan tipe parameter serta tipe kembalian.

// (Int, Int) -> String


// Setiap function type memiliki tanda kurung . Di dalamnya terdapat sebuah parameter dan jumlah tipe yang menandakan jumlah parameter dari fungsi tersebut. Pada contoh di atas, fungsi tersebut memiliki 2 (dua) parameter dengan tipe Int dan memiliki tipe kembalian String. Ketika kita tidak ingin fungsi tersebut mengembalikan nilai, kita bisa menggunakan Unit. Berbeda dengan fungsi pada umumnya, jika menggunakan tipe kembalian Unit, kita tidak wajib menuliskannya.

// Ketika kita mempunyai beberapa fungsi yang memiliki function type yang sama, kita bisa menyederhanakannya. Bagaimana caranya? Manfaatkan kata kunci typealias untuk memberikan nama alternatif dari sebuah function type seperti berikut:

typealias Arithmetic = (Int, Int) -> Int

fun main() {

    

    val sum: Arithmetic = { valueA, valueB -> valueA + valueB }
 
    val multiply: Arithmetic = { valueA, valueB -> valueA * valueB }

    // typealias cocok digunakan ketika kita mempunyai sebuah function type yang panjang. Dengannya, kita bisa memberikan nama untuk sebuah function type dan menggunakannya sebagai tipe untuk fungsi lainnya. Nah, sekarang kalau dilihat sudah benar-benar mirip seperti tipe data kan? Mantap!

    // Untuk membuat instance dari sebuah function type, terdapat beberapa cara. Salah satunya dengan lambda expression yang sudah kita bahas pada sub-modul sebelumnya. Sedangkan untuk menggunakan instance-nya, kita bisa memanfaatkan operator invoke() seperti berikut:

    val sumResult = sum.invoke(10, 10)
    val multiplyResult = multiply.invoke(20, 20)

    println(sumResult)
    println(multiplyResult)

    // Atau kita bisa menuliskannya secara langsung dengan menghilangkan operator invoke():


    val sumResult1 = sum(10, 10)
    val multiplyResult1 = multiply(20, 20)

    println(sumResult1)
    println(multiplyResult1)

    // Kita juga bisa menandai function type sebagai nullable dengan menempatkannya di dalam tanda kurung dan diakhiri dengan safe call seperti berikut:

    // typealias Arithmetic1 = ((Int, Int) -> Int)?

    // val sum2: Arithmetic1 = { valueA, valueB -> valueA + valueB }

    // val sumResult2 = sum2?.invoke(10, 10)

    // println(sumResult2)
}