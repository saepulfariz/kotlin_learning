/*
 * This source file was generated by the Gradle 'init' task
 */
package com.dicoding.kotlin

// Lambda
// Lambda expression, biasa disebut dengan anonymous function atau function literal adalah fitur yang cukup populer sampai sekarang dalam dunia functional programming. Bisa disebut sebagai anonymous karena lambda tidak memiliki sebuah nama seperti halnya sebuah fungsi pada umumnya. Karena merupakan sebuah fungsi, lambda juga dapat memiliki daftar parameter, body dan return type. Istilah lambda sendiri berasal dari istilah akademis lambda calculus yang digunakan untuk menggambarkan proses komputasi.

// Untuk memudahkan Anda dalam memahami perbedaan Lambda, silakan lihat contoh kode berikut.

// Regular Function


fun getMessage(name: String): String {
    return "Hello $name"
}

//  Function dengan Lambda

val message1 :(String) -> String = { name: String ->
    "Hello $name"
}


// Sebelum mempelajarinya lebih dalam, ada baiknya jika kita tahu beberapa karakteristik dari lambda sebagai berikut.

// Dalam menggunakan lambda, kita tidak perlu mendeklarasi tipe spesifik untuk nilai kembaliannya. Tipe tersebut akan ditentukan oleh kompiler secara otomatis.
// Walaupun merupakan sebuah fungsi, lambda tidak membutuhkan kata kunci fun dan visibility modifier saat dideklarasikan karena lambda bersifat anonymous.
// Parameter yang akan ditetapkan berada di dalam kurung kurawal {}. 
// Ketika ingin mengembalikan nilai, kata kunci return tidak diperlukan lagi karena kompiler akan secara otomatis mengembalikan nilai dari dalam body.
// Lambda expression dapat digunakan sebagai argumen untuk sebuah parameter dan dapat disimpan ke dalam sebuah variabel.
// Dari beberapa karakteristik di atas, lambda sangat berguna karena dapat membuat penulisan kode menjadi lebih mudah dan sederhana. Salah satu contohnya adalah kita bisa menghindari boilerplate code dalam menggunakan anonymous class seperti berikut.

/*
val comparator = object :Runnable{
    override fun run() {
        // TODO:
    }
}

Dengan lambda, kita bisa menyederhanakannya menjadi seperti di bawah ini.

val comparator = Runnable {
    // TODO:
}
*/


// Menggunakan Lambda Expression
// Setelah mengetahui apa itu lambda dan karakteristiknya, bagaimana cara mendeklarasikannya? Perhatikan contoh kode di bawah ini.

val message = { println("Hello From Lambda") }

// Kode di atas adalah contoh deklarasi dari lambda versi ringkas, di mana tipe data tidak perlu dituliskan dan fungsi lambda ditandai dengan sepasang kurung kurawal. Di dalamnya terdapat fungsi untuk mencetak teks pada konsol. Ketika ingin menggunakannya, kita bisa memanggilnya seperti halnya kita memanggil sebuah fungsi pada umumnya.


// Jika ingin menambahkan sebuah parameter pada fungsi lambda, kita bisa menuliskannya seperti berikut.

val printMessage = { message: String -> println(message) }

// Seperti yang disebutkan sebelumnya, parameter dari sebuah lambda berada di dalam kurung kurawal. Untuk membedakannya dengan body, daftar parameter yang ada dipisahkan dengan tanda ->. Kemudian, bagaimana cara mendeklarasi lambda agar dapat mengembalikan nilai? Caranya, kita bisa menuliskannya seperti di bawah ini.


val messageLength = { message: String -> message.length }

// Bisa kita perhatikan, kita tidak membutuhkan tipe kembalian dan kata kunci return untuk mengembalikan sebuah nilai. Pada dasarnya, kompiler akan mengembalikan nilai berdasarkan expression atau statement di baris terakhir di dalam body.


fun main() {
    message()

    printMessage("Hello From Lambda")

    val length = messageLength("Hello From lambda")
    println("Message length $length")

    // Perulangan dengan Lambda

    // Anda masih ingat dengan perulangan forEach, bukan? Ternyata forEach adalah sebuah extension function yang menerapkan lambda. 


    val ranges = 1.rangeTo(10) step 3
    ranges.forEach { value ->
        println("value is $value!")
    }


    /*
    output :
        value is 1!
        value is 4!
        value is 7!
        value is 10!
    */

    // forEach pada kode di atas merupakan sebuah lambda expression yang hanya memiliki satu argumen, yaitu nilai tunggal yang dicakup pada ranges. Mari kita coba lihat di balik kode forEach yang membuatnya bisa dipersingkat dengan lambda.

    /*
    

    public inline fun IntArray.forEach(action: (Int) -> Unit): Unit {

        for (element in this) action(element)

    }
    
    */

    // Ternyata, forEach menggunakan perulangan for di balik layar. Dengan memanfaatkan Lambda, Anda bisa mempersingkat pemanggilannya. Selain itu, Anda juga dapat menggunakan extension forEachIndexed untuk mendapatkan indeks dari tiap nilai yang dicakup.

    ranges.forEachIndexed { index, value ->
        println("value $value with index $index")
    }

    /*
    output :
        value 1 with index 0
        value 4 with index 1
        value 7 with index 2
        value 10 with index 3
    */

    // forEachIndexed memiliki dua argumen, yakni index yang merupakan indeks dari tiap nilai dan value yang merupakan nilai tunggal yang dicakup oleh ranges itu sendiri. Jika kita hanya ingin menggunakan argumen index, kita bisa mengubah argumen value menjadi _ seperti berikut.

    ranges.forEachIndexed { index, _ ->
        println("index $index")
    }

    /*
    output :
        index 0
        index 1
        index 2
        index 3
    */

    // Sebenarnya ini merupakan sebuah aturan di mana ketika argumen dari sebuah lambda expression tidak digunakan, kita disarankan agar mengubahnya menjadi _ untuk menggantikan nama dari argumen tersebut.
}